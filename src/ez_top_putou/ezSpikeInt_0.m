function spike = ezSpikeInt_0(hdat,vdat,cdat,tC);

if nargin == 3
    tC = 0.3;
end

N = 1201;
Fs = 2000;
t = [1:N]/Fs;

fmin = 30;
fmax = 80;
omega = 4;

tBuf1 = 0.1;
tEdge = 0.03;

gSize = 500;
foi = [80 240];
nCont = 50;

thresh_m = 0.0257;
thresh_b = 0.7874;

% Determine Start and End times of the Region Of Interest
tS = tC - tBuf1;
tE = tC + tBuf1;
if tS <= tEdge
    tS = tEdge;
    tE = tEdge + 2*tBuf1;
elseif tE >= t(end) - tEdge
    tS = t(end) - tEdge - 2*tBuf1;
    tE = t(end) - tEdge;
end

vdat0 = vdat;
hdat0 = hdat(hdat >= tS & hdat <= tE);
cdat1 = cdat(ismember(vdat,vdat0), ismember(hdat,hdat0));

% CALCULATE GRADIENT
[gX gY] = gradient(cdat1);
gR = (gX.^2 + gY.^2).^(1/2);

% OBJECTS AND VOLUMES
%     Identify Seperate objects in the final density array.
%     Using Surface Generated by zDet3_2c.m using Patient 456, Trial 9.3

% TF MAP (cdat1)
% Remove Magnitudes below 20% max cdat1 value
thrC= 0.2*max(cdat1(:));
cT0 = cdat1;
cT0(cdat1 < thrC) = 0; 
cT = cT0;

% Binarize Remaining TF plot
cBW = cT;
cBW(cdat1 >= thrC) = 1;

% Find Boundaries to Determine Number of Seperate Blobs 
[cB cL] = bwboundaries(cBW);

% FIX ERROR: Occasionally cB contains an empty cell due to
% close boundaries.
for ii = 1:size(cB,1)
    if isempty(cB{ii,1})
        cbw = zeros(size(cL));
        cbw(cL == ii) = 1;
        cBmissing = bwboundaries(cbw);
        cB(ii,1) = cBmissing;
    end
end

% Size of B yields number of objects
nObjC = size(cB,1);

    % Spike Times Adjusted 
    cTt = cdat;
    cTt(cdat < thrC) = 0;
    cTt(cdat >= thrC) = 1;
    [cBt cLt] = bwboundaries(cTt);
    for ii = 1:size(cBt,1)
        if isempty(cBt{ii,1})
            cbw = zeros(size(cLt));
            cbw(cLt == ii) = 1;
            cBmissing = bwboundaries(cbw);
            cBt(ii,1) = cBmissing;
        end
        tAdj(ii,:) = [min(hdat(cBt{ii,1}(:,2))) max(hdat(cBt{ii,1}(:,2)))];
    end

% CALCULATE OBJECT VOLUME

% For each object Grab Objects Indices
cObj = {};
for bb = 1:nObjC
    if ~isempty(cB{bb,1})
        % Logical Array: Determine which indices of HV fall within (or on) obj1's borders
        % objL = inpolygon(H, V, hdat0(cB{bb,1}(:,2)), vdat0(cB{bb,1}(:,1)));
        cObjL{bb} = zeros(size(cL));
        cObjL{bb}(cL == bb) = 1;

        % Restore dens values for that object only
        cObj{bb,1} = cT; 
        cObj{bb,1}(find(~cObjL{bb})) = 0;

        % Calculate Volume of Object
        cObj{bb,2} = trapz(vdat0, trapz(hdat0, cObj{bb,1}, 2), 1);

        % Calculate Start/Stop Times of Object
        cObj{bb,3} = [min(hdat0(cB{bb,1}(:,2))) max(hdat0(cB{bb,1}(:,2)))];
        for cc = 1:size(tAdj,1)
            if tAdj(cc, 1) == min(hdat0(cB{bb,1}(:,2))) || tAdj(cc,2) == max(hdat0(cB{bb,1}(:,2)))
                cObj{bb,3} = tAdj(cc,:);
            end
        end

        % Include index just in case
        cObj{bb,4} = bb;

    else
        nObjC = nObjC - 1;
    end
end
cObj_Ref = cObj;

% GRADIENT

% Remove Densities below 20% max grad value
thrG= 0.2*max(gR(:));
gT0 = gR;
gT0(gR < thrG) = 0; 
gT = gT0;
% Binarize Remaining Density Map
gBW = gT;
gBW(gR >= thrG) = 1;

% Find Boundaries to Determine Number of Seperate Blobs 
[gB gL] = bwboundaries(gBW);

% FIX ERROR: Occasionally cB contains an empty cell due to
% close boundaries.
for ii = 1:size(gB,1)
    if isempty(gB{ii,1})
        gbw = zeros(size(gL));
        gbw(gL == ii) = 1;
        gBmissing = bwboundaries(gbw);
        gB(ii,1) = gBmissing;
    end
end

% Size of B yields number of objects
nObjG = size(gB,1);

% CALCULATE OBJECT VOLUME
gObj = {};
gObjL = {};
%             gObjVol = [];
% For each object Grab Objects Indices
for bb = nObjG:-1:1
    if ~isempty(gB{bb,1})
        % Logical Array: Determine which indices of HV fall within (or on) obj1's borders
        gObjL{bb} = zeros(size(gL));
        gObjL{bb}(gL == bb) = 1;

        % Restore Volume values for that object only
        gObj{bb,1} = gT; 
        gObj{bb,1}(find(~gObjL{bb})) = 0;

        % Calculate Volume of Object
        gObj{bb,2} = trapz(vdat0, trapz(hdat0, gObj{bb}, 2), 1);

        % Calculate Start/Stop Times of Object
        gObj{bb,3} = [min(hdat0(gB{bb,1}(:,2))) max(hdat0(gB{bb,1}(:,2)))];

        % Include index just in case
        gObj{bb,4} = bb;

    else
        gB(bb,:) = [];
        nObjG = nObjG - 1;
    end
end

% 1a. Remove Gradient objects w/ Volume <= 0.1
gNlist = [];
gPkVal = [];
for bb = nObjG:-1:1
    if gObj{bb,2} <= 0.1
        gT(gL == bb) = 0;
        gB(bb,:) = [];
        gObj(bb,:) = [];
    else
        [pkvalG indG] = max(gObj{bb,1}(:));
        [rG cG] = ind2sub(size(gObj{bb,1}), indG);
        gNlist = [bb; gNlist];
        gPkVal = [ pkvalG; gPkVal];
    end
end
nObjG = size(gObj,1);
cNlist = []; 
cPkVal = [];
for bb = nObjC:-1:1
    if cObj{bb,2} <= 5
        cObj(bb,:) = [];
    else
        [pkval ind] = max(cObj{bb,1}(:));
        [rC cC] = ind2sub(size(cObj{bb,1}), ind);
        cvdat0 = vdat0'.*cObjL{bb};
        % Remove objects at the edge
        if hdat0(cC) <= (tEdge + .01) || hdat0(cC) >= (t(end) - tEdge - .01) || (vdat0(rC) == 80 && min(cvdat0(cvdat0 ~= 0)) >= 55)
            cObj(bb,:) = [];
        else
            cNlist = [bb; cNlist];
            cPkVal = [ [pkval ind]; cPkVal];
        end
    end
end
nObjC = size(cObj,1);

if nObjC ~= 0 & nObjG ~= 0

    % 2. Calculate some properties to investigate

    % 2a. Bounding Box for cdat Object (width/height)
    cXscale = size(cdat1,1)/size(cdat1,2);                      % Calculate x-axis scaling factor

    % Calculate time coordinate of peak cdat value
    cnobj = find(cPkVal(:,1) == max(cPkVal(:,1)));              % Determine cdat Object with peak cdat value
    [cv ch] = ind2sub(size(cObj{[cObj{:,4}] == cNlist(cnobj),1}),cPkVal(cnobj,2));
    ctmax = hdat0(ch);
    chdat0 = hdat0(hdat0 >= ctmax - 0.1 & hdat0 <= ctmax + 0.1);

    % Calculate Properties
    cBB =  regionprops(cObjL{cNlist(cnobj)}, 'BoundingBox','Extent');     
    cBoxRatio = cBB.BoundingBox(1,4) / (cBB.BoundingBox(1,3)*cXscale);

%     % Identify Grad Objects within 0.1 s of the chosen cdat Object
%     gVol = [];
%     for bb = 1:nObjG
%         if ~isempty(intersect(hdat0.*gObjL{gNlist(bb)},chdat0))
%             gVol = [gVol; gObj{bb,2}];
%         end
%     end
%     nObjG = size(gVol,1);
% 
%     % CONDITIONS FOR SPIKE DETECTION
%     if nObjG == 1; 
%         gTotVol = gObj{:,2};
%         gVol = gObj{:,2};
%     else
%         % TRIAL 1: SUM 2 HIGHEST GRAD OBJECT VOLUMES WITHIN 0.1s OF CDAT OBJECT
%         gSortVol = sort(gVol,'descend');	% Sort Gradient Object Volumes
%         if length(gVol) == 0;
%             gTotVol = 0;
%         elseif length(gVol) == 1;
%             gTotVol = gSortVol;
%         else
%             gTotVol = sum(gSortVol(1:2));
%         end
%     end

            % 3.1 CONDITIONS FOR SPIKE DETECTION: TRIAL 1
                % BUG FIX: does not account for gObj with start times
                % before cObj AND end times after cObj
            tc = cObj{find(cell2mat(cObj(:,2)) == max(cell2mat(cObj(:,2)))),3};
            t1a = [cell2mat(gObj(:,3)) >= tc(1)]; 
            t2a = [cell2mat(gObj(:,3)) <= tc(2)];
            ig2a = find(sum(t1a .* t2a,2));
            ig2b = find(t1a(:,2) & t2a(:,1));
            ig2 = unique([ig2a; ig2b]);
            % ig2 = find(sum([cell2mat(gObj(:,3)) >= tc(1)] .* [cell2mat(gObj(:,3)) <= tc(2)],2));
            gTotVol = sum([gObj{ig2,2}]);

    % Threshold Coordinate Test
    x = cObj{cnobj,2};
    y = gTotVol;
    if (y >= (thresh_m*x + thresh_b))
        spike(1,:) = {1 cObj{cnobj,3}(1) cObj{cnobj,3}(2)};
    else
        spike(1,:) = {0 0 0};
    end
else
    spike(1,:) = {0 0 0};
end
